(ns phel\core
  (:use Phel\Lang\Phel)
  (:use Phel\Lang\Tuple)
  (:use Phel\Lang\Keyword)
  (:use Phel\Lang\IContactable)
  (:use Phel\Lang\PhelArray)
  (:use Phel\Lang\Table)
  (:use Phel\Lang\Nil)
  (:use Phel\Lang\ICons)
  (:use Phel\Lang\ISlice)
  (:use Phel\Lang\IIdentical)
  (:use Phel\Lang\ICdr)
  (:use Phel\Lang\IPop)
  (:use Phel\Lang\IPush)
  (:use Phel\Lang\IRest)
  (:use Phel\Lang\IRemove)
  (:use Phel\Lang\IConcat)
  (:use Phel\Lang\Symbol)
  (:use Phel\Printer)
  (:use Countable)
  (:use Exception)
  (:use InvalidArgumentException))

# ------------------
# Basic constructors
# ------------------

(def tuple 
  "Creates a new Tuple. If no argument is provided, an empty Tuple is created."
  (fn [& xs] (php/new Tuple (php/-> xs (toPhpArray)))))

(def tuple-brackets 
  "Creates a new Bracket-Tuple. If no argument is provided, 
an empty Braket-Tuple is created."
  (fn [& xs] (php/new Tuple (php/-> xs (toPhpArray)) true)))

(def array
  "Creates a new Array. If no argument is provided, an empty Array is created."
  (fn [& xs] xs))

(def table 
  "Creates a new Table. If no argument is provided, an empty Table is created. 
The number of parameters must be even."
  (fn [& xs] (php/:: Table (fromKVArray (php/-> xs (toPhpArray))))))

(def keyword
  "Creates a new Keyword from a given string."
  (fn [x] (php/new Keyword x)))

# --------------------------------------------
# Basic methods for quasiquote and destructure
# --------------------------------------------

(def next
  "Returns the sequence of elements after the first element. If there are no 
elements, returns nil."
  (fn [xs]
    (if (php/== xs nil)
      nil
      (if (php/instanceof xs ICdr)
        (php/-> xs (cdr))
        (if (php/is_array xs)
          (let [sliced (php/array_slice xs 1)]
            (if (php/empty sliced)
              nil
              sliced))
          (throw (php/new InvalidArgumentException 
                    (php/. "can not do next" (php/gettype xs)))))))))

(def concat1 (fn [xs ys]
  (if (php/instanceof xs IConcat)
    (php/-> xs (concat ys))
    (do
      (foreach [y ys]
        (php/apush xs y))
      xs))))

(def concat (fn [arr & xs]
  (loop [res arr
         [y & ys] xs]
    (if (php/== nil y)
      res
      (recur (concat1 res y) ys)))))

# quasiquote can be used down here

# ------------
# Basic macros
# ------------

(def defn :macro 
  (fn [name & more]
    (let [[mods fnArgs] (loop [[x & xs] more
                               modifiers []]
                               (if x
                                 (if (php/instanceof x Tuple)
                                   [modifiers (concat [x] xs)]
                                   (recur xs (concat modifiers [x])))))]
      `(def ,name ,@mods (fn ,@fnArgs)))))

(defn defmacro :macro
  "Define a macro"
  [name & more]
  (apply defn name :macro more))

(defmacro defmacro-
  "Define a private macro that will not be exported"
  [name & more]
  (apply defn name :macro :private more))

(defmacro defn-
  "Define a private function that will not be exported"
  [name & more]
  (apply defn name :private more))

(defn def-
  "Define a private value that will not be exported"
  [name & more]
  `(def ,name :private ,@more))

(defmacro comment 
  "Ignores the body of the comment"
  [&])

(defn gensym 
  "Generates a new unique symbol."
  []
  (php/:: Symbol (gen)))

(defn str
  "Creates a string by concatenating values together. If no arguments are 
provided an empty string is returned. Nil and false are represented as empty 
string. True is represented as 1. Otherwise it tries to call __toString. 
This is PHP equalivalent to `$args[0] . $args[1] . $args[2] ...`"
  [& args]
  (if args
    (apply php/. args)
    ""))

# -------------------------
# Basic sequence operations
# -------------------------

(defn cons [x xs]
  (if (php/is_array xs)
    (do
      (php/array_unshift xs x)
      xs)
    (if (php/instanceof xs ICons)
      (php/-> xs (cons x))
      (if (php/== xs nil)
        @[x]
        (throw (php/new InvalidArgumentException 
                  (php/. "can not do cons " (php/print_r x true))))))))

(defn first
  "Returns the first element of an indexed sequence or nil."
  [xs]
  (php/aget xs 0))

(defn second 
  "Returns the second element of an indexed sequence or nil."
  [xs]
  (php/aget xs 1))

(defn rest 
  "Returns the sequence of elements after the first element. If there are no 
elements, returns an empty sequence."
  [xs]
  (if (php/instanceof xs IRest)
    (php/-> xs (rest))
    (if (php/is_array xs)
      (php/array_slice xs 1)
      (throw (php/new InvalidArgumentException "can not do rest")))))

(defn count 
  "Counts the number of elements in a sequence. Can be used on everything that 
implement the PHP Countable interface."
  [xs]
  (if (php/instanceof xs Countable)
    (php/-> xs (count))
    (if (php/is_array xs)
      (php/count xs)
      (if (php/== xs nil)
        0
        (throw (php/new InvalidArgumentException "object is not countable"))))))

# ------------------------
# Control structure macros
# ------------------------

(defmacro if-not
  "Shorthand for (if (not condition) else then)."
  [test then & [else]]
  `(if ,test ,else ,then))

(defmacro when 
  "Evaluates test and if that is logical true, evaluates body"
  [test & body]
  `(if ,test (do ,@body)))

(defmacro when-not
  "Evaluates test and if that is logical true, evaluates body"
  [test & body]
  `(if ,test nil (do ,@body)))

(defmacro cond [& pairs]
  (let [cnt (count pairs)]
    (if (php/== cnt 0)
      nil
      (if (php/== cnt 1)
        (first pairs)
        (tuple 'if
               (first pairs)
               (second pairs)
               (cons 'cond (apply tuple (next (next pairs)))))))))

(defmacro case [expr & pairs]
  (if (next pairs)
    (let [v (gensym)]
      `(let [,v ,expr]
        (if (php/== ,v ',(first pairs))
          ,(first (next pairs))
          (case ,v ,@(next (next pairs))))))
    (first pairs)))

# ----------------
# Boolen operation
# ----------------

(defmacro or
  "Evaluates each expression one at a time, from left to right. If a form 
returns a logical true value, or returns that value and doesn't evaluate any of 
the other expressions, otherwise it returns the value of the last expression. 
Calling or without arguments, returns nil."
  [& args]
  (case (count args)
    0 nil
    1 (first args)
      (let [v (gensym)]
        `(let [,v ,(first args)]
          (if ,v ,v (or ,@(next args)))))))

(defmacro and
  "Evaluates each expression one at a time, from left to right. If a form 
returns logical false, and returns that value and doesn't evaluate any of the 
other expressions, otherwise it returns the value of the last expression. 
Calling the and function without arguments returns true."
  [& args]
  (case (count args)
    0 'true
    1 (first args)
      (let [v (gensym)]
        `(let [,v ,(first args)]
          (if ,v (and ,@(next args)) ,v)))))

(defn- id2 [a b]
  (if (php/instanceof a IIdentical)
    (php/-> a (identical b))
    (php/=== a b)))

(defn id 
  "Checks if all values are identically. Same as a === b in PHP."
  [a & more]
  (case (count more)
    0 true
    1 (id2 a (first more))
      (if (id2 a (first more))
        (recur (first more) (next more))
        false)))

(defn = 
  "Checks if all values are equal. Same as a == b in PHP."
  [a & more]
  (case (count more)
    0 true
    1 (php/== a (first more))
      (if (php/== a (first more))
        (recur (first more) (next more))
        false)))

(defn not 
  "The `not` function returns `true` if the given value is logical false and 
`false` otherwise."
  [x]
  (if x false true))

(defn not= [a & more]
  (case (count more)
    0 false
    1 (not (= a (first more)))
      (not (apply = a more))))

(defn <
  "Check if all given values are in ascending order. Returns a boolean."
  [a & more]
  (case (count more)
    0 true
    1 (php/< a (first more))
      (if (php/< a (first more))
        (recur (first more) (next more))
        false)))

(defn <=
  "Check if all given values are in a non-descending order. Returns a boolean."
  [a & more]
  (case (count more)
    0 true
    1 (php/<= a (first more))
      (if (php/<= a (first more))
        (recur (first more) (next more))
        false)))

(defn >
  "Check if all given values are in descending order. Returns a boolean."
  [a & more]
  (case (count more)
    0 true
    1 (php/> a (first more))
      (if (php/> a (first more))
        (recur (first more) (next more))
        false)))

(defn >=
  "Check if all given values are in non-ascending order. Returns a boolean."
  [a & more]
  (case (count more)
    0 true
    1 (php/>= a (first more))
      (if (php/>= a (first more))
        (recur (first more) (next more))
        false)))

(defn all [pred xs]
  (cond
    (php/== (count xs) 0) true
    (pred (first xs))     (recur pred (next xs))
                          false))
(defn some [pred xs]
  (if xs
    (or (pred (first xs)) (recur pred (next xs)))))

(defn true?
  "Checks if x is true. Same as x === true in PHP."
  [x]
  (id x true))

(defn truthy?
  "Checks if x is truthy. Same as x == true in PHP."
  [x]
  (= x true))

(defn false? 
  "Checks if x is false. Same as x === false in PHP."
  [x]
  (id x false))

# --------------
# Type operation
# --------------

(defn type 
  [x]
  (cond
    (php/instanceof x Tuple)      :tuple
    (php/instanceof x PhelArray)  :array
    (php/instanceof x Table)      :table
    (php/instanceof x Keyword)    :keyword
    (php/instanceof x Symbol)     :symbol
    (php/is_int x)                :int
    (php/is_float x)              :float
    (php/is_string x)             :string
    (php/is_null x)               :nil
    (php/is_bool x)               :boolean
    (php/is_callable x)           :function
    (php/is_array x)              :php/array
    (php/is_resource x)           :php/resource
    (php/is_object x)             :php/object
                                  :unknown))

(defn nil? [x]
  (id x nil))

(defn float? [x]
  (= (type x) :float))

(defn int? [x]
  (= (type x) :int))

(defn number? [x]
  (or (= (type x) :int) (= (type x) :float)))

(defn string? [x]
  (= (type x) :string))

(defn keyword? [x]
  (= (type x) :keyword))

(defn symbol? [x]
  (= (type x) :symbol))

(defn function? [x]
  (= (type x) :function))

(defn table? [x]
  (= (type x) :table))

(defn array? [x]
  (= (type x) :array))

(defn tuple? [x]
  (= (type x) :tuple))

(defn boolean? [x]
  (= (type x) :boolean))

(defn php-array? [x]
  (= (type x) :php/array))

(defn php-resource? [x]
  (= (type x) :php/resource))

(defn php-object? [x]
  (= (type x) :php/object))

(defn empty? [x]
  (= 0 (count x)))

(defn dict? [x]
  (= (type x) :table))

(defn indexed? [x]
  (let [t (type x)]
    (or (= t :array) (= t :tuple) (= t :php/array))))

# ------------------
# Sequence operation
# ------------------

(defn peek
  "Returns the last element of an array. Does not modify the sequence."
  [xs]
  (php/aget xs (php/- (count xs) 1)))

(defn push
  "Inserts x at the end of the array xs. Modifies the array."
  [xs x]
  (cond
    (php-array? xs) (throw (php/new InvalidArgumentException "Can not call push
on pure PHP arrays because Phel does not have support for call-by-reference"))
    (php/instanceof xs IPush) (php/-> xs (push x))
    (throw (php/new InvalidArgumentException 
              (str "Can not push on type " (type xs))))))

(defn pop
  "Removes the the last element of the array. If the array is empty return nil. 
Modifiles the array."
  [xs]
  (cond
    (php-array? xs) (throw (php/new InvalidArgumentException "Can not call pop
on pure PHP arrays because Phel does not have support for call-by-reference" ))
    (php/instanceof xs IPop) (php/-> xs (pop))
    (throw (php/new InvalidArgumentException "Can not pop"))))

(defn remove
  "Removes up to n element from xs starting at index offset."
  [xs offset & [length]]
  (cond
    (php-array? xs) (throw (php/new InvalidArgumentException "Can not call
remove on pure PHP arrays because Phel does not have support for
call-by-reference"))
    (php/instanceof xs IRemove) (php/-> xs (remove offset length))
    (throw (php/new InvalidArgumentException "Can not remove"))))

(defn get 
  [ds k & [opt]]
  (let [res (php/aget ds k)]
    (if (nil? res)
      opt
      res)))

(defn put
  [ds key value]
  (do
    (when (php-array? ds)
      (throw (php/new InvalidArgumentException "Can not call put on pure PHP 
arrays because Phel does not have support for call-by-reference" )))
    (if (nil? value)
      (php/aunset ds key)
      (php/aset ds key value))
    ds))

(defn map [f & xs]
  (case (count xs)
    0 (throw (php/new InvalidArgumentException "expected at least one indexed
collection in map"))
    1 (loop [res (array)
             seq (first xs)]
        (if (nil? (first seq))
          res
          (do
            (push res (f (first seq)))
            (recur res (next seq)))))
      (loop [res (array)
             seq xs]
        (if (some nil? seq)
           res
           (do 
             (push res (apply f (map first seq)))
             (recur res (map next seq)))))))

(defn reduce [f init xs]
  (if (nil? (first xs))
    init
    (recur f (f init (first xs)) (next xs))))

(defn reduce2 [f [x & xs]]
  (reduce f x xs))

(defn slice
  [xs & [offset & [length]]]
  (cond
    (php-array? xs) (php/array_slice xs offset length)
    (php/instanceof xs ISlice) (php/-> xs (slice offset length))
    (throw (php/new InvalidArgumentException "Can not slice"))))

(defn get-in
  [ds ks & [opt]]
  (let [res (reduce get ds ks)]
    (if (nil? res) opt res)))

(defn put-in
  [ds [k & ks] v]
  (if-not (nil? ks)
    (put ds k (put-in (get ds k @{}) ks v))
    (put ds k v)))

(defn update
  [ds k f & args]
  (put ds k (apply f (get ds k) args)))

(defn update-in
  [ds [k & ks] f & args]
  (if ks
    (put ds k (apply update-in (get ds k @{}) ks f args))
    (put ds k (apply f (get ds k) args))))

(defn drop [n xs]
  (slice xs (if (php/< n 0) 0 n)))

(defn drop-while [pred xs]
  (loop [s xs]
    (if (and s (pred (first s)))
      (recur (rest s))
      s)))

(defn take [n xs]
  (slice xs 0 (if (php/< n 0) 0 n)))

(defn take-while [pred xs]
  (loop [s xs
         res @[]]
    (if (and s (pred (first s)))
      (recur (rest s) (push res (first s)))
      res)))

(defn filter [pred xs]
  (let [res @[]]
    (foreach [x xs]
      (when (pred x)
        (push res x)))
    res))

(defn keep [pred xs]
  (let [res @[]]
    (foreach [x xs]
      (let [predRes (pred x)]
        (when-not (nil? predRes)
          (push res predRes))))
    res))

(defn find [pred xs]
  (loop [s xs]
    (if s
      (if (pred (first s))
        (first s)
        (recur (next s)))
      nil)))

(defn find-index [pred xs]
  (loop [s xs
         i 0]
    (if s
      (if (pred (first s))
        i
        (recur (next s) (php/+ i 1)))
      nil)))

# TODO: accumulate, accumulate2, distinct, every?, flatten, flatten-into, frequencies, in, interleave, interpose, invert, keys, kvs, last, mapcat, max, mean, merge, merge-into, min, pairs, range, sort, sorted, sum, values, walk, zipcoll, butlast, ffirst, group-by, keep-indexed, map-indexed, nfirst, nnext, not-any, not-every, partition, partition-all, partition-by, reduce-kv, repeat, replace, reverse, shuffle, split-at, split-with, to-php-array, to-php-iterator, rand, rand-int
# TODO: Binary operations

# ------------------
# Function operation
# ------------------

(defn identity [x] x)

(defn comp [& fs]
  (case (count fs)
    0 identity
    1 (first fs)
    2 (fn [& args] ((first fs) (apply (second fs) args)))
      (reduce2 comp fs)))

(defn complement [f]
  (fn [& args] (not (apply f args))))

(defn juxt [& fs]
  (fn [& args]
    (reduce 
      (fn [arr f] (push arr (apply f args))) 
      @[] 
      fs)))

(defn partial [f & args]
  (fn [& more] (apply f (concat args more))))

# -----------------
# Bitwise operation
# -----------------

(defn bit-and [x y & args]
  (let [all (concat [x y] args)]
    (reduce2 (fn [a b] (php/& a b)) all)))

(defn bit-or [x y & args]
  (let [all (concat [x y] args)]
    (reduce2 (fn [a b] (php/| a b)) all)))

(defn bit-xor [x y & args]
  (let [all (concat [x y] args)]
    (reduce2 (fn [a b] (php/^ a b)) all)))

(defn bit-not [x]
  (php/~ x))

(defn bit-shift-left [x n]
  (php/<< x n))

(defn bit-shift-right [x n]
  (php/>> x n))

(defn bit-set [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-clear [x n]
  (bit-and x (bit-not (bit-shift-left 1 n))))

(defn bit-flip [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-test [x n]
  (php/!= 0 (bit-and x (bit-shift-left 1 n))))

# --------------
# Math operation
# --------------

(def NAN php/NAN)

(defn +
  "Returns the sum of all elements in xs. All elements is xs must be numbers.
If xs is empty, return 0."
  [& xs] 
  (if (empty? xs)
    0
    (apply php/+ xs)))

(defn -
  "Returns the difference of all elements in xs. If xs is empty, return 0. If xs
has one element, return the negative value of that element."
  [& xs]
  (case (count xs)
    0 0
    1 (php/* -1 (first xs))
    2 (php/- (first xs) (second xs))
      (reduce2 (fn [a b] (php/- a b)) xs)))

(defn *
  "Returns the product of all elements in xs. All elements is xs must be 
numbers. If xs is empty, return 1."
  [& xs] 
  (case (count xs)
    0 1
    1 (first xs)
    2 (php/* (first xs) (second xs))
      (reduce2 (fn [a b] (php/* a b)) xs)))

(defn /
  "Returns the nominator divided by all of the denominators. If xs is empty,
returns 1. If xs has one value, returns the reciprocal of x."
  [& xs]
  (case (count xs)
    0 1
    1 (php// 1 (first xs))
    2 (php// (first xs) (second xs))
      (reduce2 (fn [a b] (php// a b)) xs)))

(defn % 
  "Return the remainder of dividend / divisor."
  [dividend divisor]
  (php/% dividend divisor))

(defn ** 
  "Return a to the power of x."
  [a x]
  (php/** a x))

(defn inc
  "Increments x by one."
  [x]
  (+ x 1))

(defn dec
  "Decrements x by one."
  [x]
  (- x 1))

(defn even?
  "Checks if x is even."
  [x]
  (= 0 (% x 2)))

(defn odd?
  "Checks if x is odd."
  [x]
  (= 1 (% x 2)))

(defn zero?
  "Checks if x is zero."
  [x] 
  (= x 0))

(defn one?
  "Checks if x is one."
  [x] 
  (= x 1))

(defn pos?
  "Checks if x is greater than zero."
  [x]
  (> x 0))

(defn neg?
  "Checks if x is smaller than zero."
  [x] 
  (< x 0))

(defn nan?
  "Checks wheater the value is not a number"
  [x]
  (php/is_nan x))

# ----------------
# Print operations
# ----------------

(defmacro with-output-buffer [& body]
  (let [res (gensym)]
    `(do
      (php/ob_start)
      ,@body
      (let [,res (php/ob_get_contents)]
        (php/ob_end_clean)
        ,res))))

(defn print-str [& xs]
  (let [len (count xs)
        printer (php/new Printer)
        pp (fn [x] (php/-> printer (print x false)))]
    (cond
      (= len 0) ""
      (= len 1) (php/-> printer (print (first xs) false))
                (loop [res (php/-> printer (print (first xs) false))
                       seq (next xs)]
                  (if seq
                    (recur 
                      (str res " " (php/-> printer (print (first seq) false))) 
                      (next seq))
                    res)))))

(defn print [& xs]
  (php/print (apply print-str xs)))

(defn println [& xs]
  (do 
    (apply print xs)
    (php/print "\n")))