(ns phel\core
  (:use Phel\Lang\Phel)
  (:use Phel\Lang\Tuple)
  (:use Phel\Lang\IContactable)
  (:use Phel\Lang\PhelArray)
  (:use Phel\Lang\Nil)
  (:use Phel\Lang\ICons)
  (:use Phel\Lang\ISlice)
  (:use Phel\Lang\ICdr)
  (:use Phel\Lang\IRest)
  (:use Phel\Lang\Symbol)
  (:use Countable)
  (:use Exception)
  (:use InvalidArgumentException))

(def drop-destructure (fn [n x]
  (if (php/is_array x)
    (php/array_slice x n)
    (if (php/instanceof x ISlice)
      (php/-> x (slice n))
      (throw (php/new InvalidArgumentException "this is not sliceable"))))))

(def tuple (fn [& xs] (php/new Tuple (php/-> xs (toPhpArray)))))

(def concat (fn [arr & xs]
  (do
    (foreach [x xs]
      (foreach [value x]
        (php/apush arr value)))
    arr)))

(def array (fn [& xs] xs))

# quasiquote can be used down here

(def defn :macro 
  (fn [name & more]
    (let [[mods fnArgs] (loop [[x & xs] more
                               modifiers []]
                               (if x
                                 (if (php/instanceof x Tuple)
                                   [modifiers (concat [x] xs)]
                                   (recur xs (concat modifiers [x])))))]
      `(def ,name ,@mods (fn ,@fnArgs)))))

(defn defmacro :macro
  "Define a macro"
  [name & more]
  (apply defn name :macro more))

(defn defmacro-
  "Define a private macro that will not be exported"
  [name & more]
  (apply defn name :macro :private more))

(defmacro defn-
  "Define a private function that will not be exported"
  [name & more]
  (apply defn name :private more))

(defn def-
  "Define a private value that will not be exported"
  [name & more]
  `(def ,name :private ,@more))

(defmacro comment 
  "Ignores the body of the comment"
  [&])

(defn str
  [& args]
  (apply php/. args))

(defn cons [x xs]
  (if (php/is_array xs)
    (do
      (php/array_unshift xs x)
      xs)
    (if (php/instanceof xs ICons)
      (php/-> xs (cons x))
      (throw (php/new InvalidArgumentException (str "can not do cons " (php/print_r x true)))))))

(defn first [xs]
  (php/aget xs 0))

(defn second [xs]
  (php/aget xs 1))

(defn next [xs]
  (if (php/instanceof xs ICdr)
    (php/-> xs (cdr))
    (if (php/is_array xs)
      (let [sliced (php/array_slice xs 1)]
        (if (php/empty sliced)
          nil
          sliced))
      (throw (php/new InvalidArgumentException "can not do next")))))

(defn rest [xs]
  (if (php/instanceof xs IRest)
    (php/-> xs (rest))
    (if (php/is_array xs)
      (php/array_slice xs 1)
      (throw (php/new InvalidArgumentException "can not do rest")))))

(defn count [xs]
  (if (php/instanceof xs Countable)
    (php/-> xs (count))
    (if (php/is_array xs)
      (php/count xs)
      (if (php/== xs nil)
        0
        (throw (php/new InvalidArgumentException "object is not countable"))))))

(defn reduce [f init xs]
  (if (first xs)
      (recur f (f init (first xs)) (next xs))
      init))

(defn reduce2 [f [x & xs]]
  (reduce f x xs))

(defmacro when 
  "Evaluates test and if that is logical true, evaluates body"
  [test & body]
  `(if ,test (do ,@body)))

(defmacro when-not
  "Evaluates test and if that is logical true, evaluates body"
  [test & body]
  `(if ,test nil (do ,@body)))

(defmacro cond [& clauses]
  (let [cnt (count clauses)]
    (if (php/== cnt 0)
      nil
      (if (php/== cnt 1)
        (first clauses)
        (tuple 'if
               (first clauses)
               (second clauses)
               (cons 'cond (apply tuple (next (next clauses)))))))))

(defn gensym 
  "generates a new unique symbol"
  []
  (php/:: Symbol (gen)))

(defmacro or
  [& args]
  (let [cnt (count args)]
    (cond
      (php/== cnt 0) 'nil
      (php/== cnt 1) (first args)
                     (let [v (gensym)]
                       `(let [,v ,(first args)]
                         (if ,v ,v (or ,@(next args))))))))

(defmacro and
  [& args]
  (let [cnt (count args)]
    (cond 
      (php/== cnt 0) 'true
      (php/== cnt 1) (first args)
                     (let [v (gensym)]
                       `(let [,v ,(first args)]
                         (if ,v (and ,@(next args)) ,v))))))